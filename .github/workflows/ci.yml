name: Continuous Integration

# This workflow runs on pushes to 'main' and on Pull Requests targeting 'main'.
# It also runs on prerelease branches to ensure quality.
on:
  push:
    branches: [ "main", "develop", "beta", "release/**", "rc/**" ]
  pull_request:
    branches: [ "main", "develop" ]

jobs:
  lint-and-format:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.13.0

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Check Zig formatting
        run: zig fmt --check src/

      - name: Check Rust formatting
        working-directory: bindings/rust
        run: cargo fmt --all -- --check

      - name: Run Rust Clippy
        working-directory: bindings/rust
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Check Rust docs
        working-directory: bindings/rust
        run: cargo doc --no-deps --document-private-items

  test-suite:
    name: Test on ${{ matrix.os }}
    # This matrix will run the same set of steps on three different operating systems.
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}

    steps:
      # Step 1: Get the source code from your repository.
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Install the Zig compiler on the build machine.
      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.13.0 # Or your preferred Zig version

      # Step 3: Install the Rust toolchain.
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      # Step 4: Run the Rust tests.
      # This is the key step. We use the 'compile-from-source' feature to force
      # the build.rs script to compile the local Zig code.
      # We also need to copy the compiled DLL to the correct location for the tests to find it.
      - name: Build and Run Rust Tests
        shell: bash
        run: |
          # Build the Rust crates and the Zig library via the build.rs script.
          # This will create the test executable and the shared library.
          cargo build --workspace --features "zrraw-sys/compile-from-source" --tests

          # --- Find the compiled library and the test executable ---
          # The exact paths can vary slightly, so we use wildcards.
          
          # On Windows, the library is a .dll
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            LIB_PATH=$(find zig-out/lib -name "zrraw.dll")
            TEST_EXE_DIR=$(find target/debug/deps -name "zrraw-*.exe" -printf "%h\n" | head -n 1)
            cp "$LIB_PATH" "$TEST_EXE_DIR/"
          fi
          
          # On macOS, the library is a .dylib
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            LIB_PATH=$(find zig-out/lib -name "libzrraw.dylib")
            TEST_EXE_DIR=$(find target/debug/deps -name "zrraw-*" ! -name "*.d" -printf "%h\n" | head -n 1)
            cp "$LIB_PATH" "$TEST_EXE_DIR/"
          fi
          
          # On Linux, the library is a .so
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            LIB_PATH=$(find zig-out/lib -name "libzrraw.so")
            TEST_EXE_DIR=$(find target/debug/deps -name "zrraw-*" ! -name "*.d" -printf "%h\n" | head -n 1)
            cp "$LIB_PATH" "$TEST_EXE_DIR/"
          fi
          
          echo "Library found at: $LIB_PATH"
          echo "Test executable directory: $TEST_EXE_DIR"
          echo "Copied library to test directory."

          # Now that the library is in the right place, run the tests.
          cargo test --workspace --features "zrraw-sys/compile-from-source"